start: grammar_declaration (import_statement | rule_statement)*

NAME: /[a-zA-Z][a-zA-Z0-9_]*/
QUALIFIED_NAME: NAME ("." NAME)*

grammar_declaration: "grammar" QUALIFIED_NAME hidden_section? with_section?
with_section: "with" QUALIFIED_NAME
hidden_section: "hidden" "(" hidden_item_list ")"
hidden_item_list: NAME ("," NAME)*


// Define the import statement rule with all its variants
import_statement: simple_import | import_with_alias
simple_import: "import" IMPORT_URL
import_with_alias: "import" IMPORT_URL "as" NAME
IMPORT_URL: QUOTED_URL | SINGLE_QUOTED_URL
QUOTED_URL: "\"" URL_CONTENT "\""
SINGLE_QUOTED_URL: "'" URL_CONTENT "'"
URL_CONTENT: /[^"']+/


DATA_TYPE: NAME "::" QUALIFIED_NAME  // Must match an imported alias


rule_statement: DECORATORS* TERMINAL? ENUM? FRAGMENT? NAME returns_section? ":" statements ";"

// Returns section (example: "returns SysML::Element")
returns_section: "returns" DATA_TYPE

// Rule to match XText rule body with alternatives and sequences
statements: alternative
alternative: sequence ("|" sequence)*
sequence: element+

element: NAME (cardinality)? | literal | group | terminal_rules | type_spec | assignment | non_parsing_assignment | predicate

// Cardinality operators
optional: "?"
multiplicity: "*" | "+"
cardinality: optional | multiplicity
negation: "!"

literal: (DOUBLE_QUOTED_STRING | SINGLE_QUOTED_STRING | WS_LITERALS) optional?
// lone backslash is not valid in a string literal
DOUBLE_QUOTED_STRING: /"(\\.|[^"])*"/ //either an escaped character or any character that isn't a double quote
SINGLE_QUOTED_STRING: /'(\\.|[^'])*'/
WS_LITERALS: SPACE_LITERAL | TAB_LITERAL | CR_LITERAL | LF_LITERAL
SPACE_LITERAL: "' '" | "\" \""  // ' ' or " "
TAB_LITERAL: "'\\t'" | "\"\\t\"" // '\t' or "\t"
CR_LITERAL: "'\\r'" | "\"\\r\"" // '\r' or "\r"
LF_LITERAL: "'\\n'" | "\"\\n\"" // '\n' or "\n"

group: negation? "(" statements ")" cardinality?

terminal_rules: char_range | wildcard | until
char_range: literal ".." literal
wildcard: literal "." literal
until: literal "->" literal

type_spec: "{" DATA_TYPE "}"

assignment: property_assignment | list_prop_assignment | bool_prop_assignment
property_assignment: type_spec? NAME "=" valid_right_sides
list_prop_assignment: type_spec? NAME "+=" valid_right_sides
bool_prop_assignment: type_spec? NAME "?=" valid_right_sides

non_parsing_assignment: non_parsing_equals | non_parsing_list
non_parsing_equals: "{" DATA_TYPE "=" valid_right_sides "}"
non_parsing_list: "{" DATA_TYPE "+=" valid_right_sides "}"

valid_right_sides: NAME | name_resolution | literal | group

name_resolution: "[" (NAME | DATA_TYPE) ("|" (NAME | DATA_TYPE))* "]"

predicate: ("->" | "=>") statements



// // match fragments separately
// fragment_statement: DECORATORS* TERMINAL? ENUM? FRAGMENT NAME returns_section? ":" frag_statements ";" 
// frag_statements: frag_alternative
// frag_alternative: frag_sequence ("|" frag_sequence)*
// frag_sequence: frag_element+
// weird_fragment: "->" NAME
// frag_group: negation? "(" frag_statements ")" cardinality?
// frag_element: element | weird_fragment | frag_group


// keywords for rule_statements
// Down at the bottom because they are self explanatory
TERMINAL: "terminal"
ENUM: "enum"
FRAGMENT: "fragment"

// Down at the bottom because they aren't very important
OVERRIDE_DECORATOR: "@Override"
FINAL_DECORARTOR: "@Final"
DEPRECATED_DECORATOR: "@Deprecated"
EXPORT_DECORATOR: "@Exported"
DECORATORS: OVERRIDE_DECORATOR | FINAL_DECORARTOR | DEPRECATED_DECORATOR | EXPORT_DECORATOR

// Have to be careful ignoring whitespace, as the grammar might include whitespace characters as literals
_WS: /[ \t\r\n]+/
_COMMENT: /\/\/[^\n]*/ | /\/\*(.|\n)*?\*\//

%ignore _WS
%ignore _COMMENT